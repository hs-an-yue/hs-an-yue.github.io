<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JDK8新特性</title>
    <url>/2024/08/03/Java8%E6%96%B0%E7%89%B9%E6%80%A7(%E5%A4%9C%E6%B3%8A2.0%E7%89%88)/</url>
    <content><![CDATA[<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Author</span><span class="punctuation">:</span> <span class="string">夜泊</span></span><br><span class="line"><span class="attribute">Email</span><span class="punctuation"> :</span> <span class="string">hd1611756908@163.com</span></span><br><span class="line"><span class="attribute">QQ</span><span class="punctuation">    :</span> <span class="string">1611756908</span></span><br><span class="line"><span class="attribute">web</span><span class="punctuation">   :</span> <span class="string">https://ukoko.gitee.io</span></span><br><span class="line"><span class="attribute">sign</span><span class="punctuation">  :</span> <span class="string">每走一步,都是进步</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>JDK发布时间</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">JDK8是2014年3月发行版本</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JDK8新特性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 日期时间API</span><br><span class="line"><span class="number">2.</span> Lambda表达式</span><br><span class="line"><span class="number">3.</span> 默认方法</span><br><span class="line"><span class="number">4.</span> 函数式接口</span><br><span class="line"><span class="number">5.</span> 方法引用</span><br><span class="line"><span class="number">6.</span> Stream API</span><br></pre></td></tr></table></figure>

<h2 id="第一章-日期和时间"><a href="#第一章-日期和时间" class="headerlink" title="第一章 日期和时间"></a>第一章 日期和时间</h2><h3 id="第1节-传统的日期时间的缺陷"><a href="#第1节-传统的日期时间的缺陷" class="headerlink" title="第1节 传统的日期时间的缺陷"></a>第1节 传统的日期时间的缺陷</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 传统的时间处理API设计很差,Java的日期/时间类的定义并不一致,在java.util和java.<span class="keyword">sql</span>的包中都有日期类</span><br><span class="line"><span class="number">2.</span> 用于格式化和解析的类却在java.text包中定义</span><br><span class="line"><span class="number">3.</span> java.util.Date同时包含日期和时间,而java.<span class="keyword">sql</span>.Date仅包含日期,这两个类还设计成相同的名字</span><br><span class="line"><span class="number">5.</span> 时区处理麻烦,传统的日期/时间API没有时区支持,所以又引入了java.util.Calendar和java.util.TimeZone类</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h3 id="第2节-新的日期时间API的优点"><a href="#第2节-新的日期时间API的优点" class="headerlink" title="第2节 新的日期时间API的优点"></a>第2节 新的日期时间API的优点</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">JDK8的java.<span class="built_in">time</span>包下涵盖了所有处理日期、时间、日期/时间、时区等的操作</span><br></pre></td></tr></table></figure>

<h4 id="2-1-时间的创建"><a href="#2-1-时间的创建" class="headerlink" title="2.1 时间的创建"></a>2.1 时间的创建</h4><h5 id="2-1-1-使用now函数"><a href="#2-1-1-使用now函数" class="headerlink" title="2.1.1 使用now函数"></a>2.1.1 使用now函数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建时间</span></span><br><span class="line"><span class="comment"> * 1. 创建当前日期时间(年月日时分秒[毫秒])</span></span><br><span class="line"><span class="comment"> * 2. 创建当前日期(年月日)</span></span><br><span class="line"><span class="comment"> * 3. 创建当前时间(时分秒[毫秒])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//创建当前日期时间(年月日时分秒[毫秒])</span></span><br><span class="line"> <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"> <span class="comment">//创建当前日期(年月日)</span></span><br><span class="line"> <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"> <span class="comment">//创建当前时间(时分秒[毫秒])</span></span><br><span class="line"> <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-使用of函数"><a href="#2-2-2-使用of函数" class="headerlink" title="2.2.2 使用of函数"></a>2.2.2 使用of函数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接构建日期时间</span></span><br><span class="line"><span class="comment"> * of: 直接构建年月日时分秒,并且将毫秒设置成0</span></span><br><span class="line"><span class="comment"> * of: 重载方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//构建年月日时分秒</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2018</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line"><span class="comment">//构建年月日</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//构建时分秒</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime1</span> <span class="operator">=</span> LocalTime.of(<span class="number">22</span>, <span class="number">22</span>, <span class="number">22</span>);</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-字符串创建"><a href="#2-2-3-字符串创建" class="headerlink" title="2.2.3 字符串创建"></a>2.2.3 字符串创建</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析字符串,字符串的格式要注意,这是年月日时分秒的默认格式2018-12-30T12:10:59或者2018-12-30T12:10:59.120</span></span><br><span class="line"><span class="comment"> * 如果是其他格式比如2018-12-30 12:10:59需要进行格式转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//默认格式1</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime2</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2018-12-30T12:10:59&quot;</span>);</span><br><span class="line"><span class="comment">//默认格式2</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime3</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2018-12-30T12:10:59.120&quot;</span>);</span><br><span class="line"><span class="comment">//非默认格式1</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime4</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2018-12-30 12:10:59&quot;</span>, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line"><span class="comment">//非默认格式2</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime5</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2019年12月30日 12时10分59秒&quot;</span>,DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="2-2-4-带时区创建"><a href="#2-2-4-带时区创建" class="headerlink" title="2.2.4 带时区创建"></a>2.2.4 带时区创建</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时区操作</span></span><br><span class="line"><span class="comment"> * 1. 获取其他时区时间</span></span><br><span class="line"><span class="comment"> * 2. 格式化时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//获取世界标准时间(UTC)</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime6</span> <span class="operator">=</span> LocalDateTime.now(ZoneId.of(<span class="string">&quot;UTC&quot;</span>));</span><br><span class="line"><span class="comment">//获取到的时间,比北京时间多8小时</span></span><br><span class="line">System.out.println(<span class="string">&quot;utc: &quot;</span>+localDateTime6);</span><br><span class="line"><span class="comment">//东8区(根据utc标准获取其他时区时间很简单,东区就+, 西区就-)</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime7</span> <span class="operator">=</span> LocalDateTime.now(ZoneId.of(<span class="string">&quot;+8&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;GMT8: &quot;</span>+localDateTime7);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-时间的获取"><a href="#2-2-时间的获取" class="headerlink" title="2.2 时间的获取"></a>2.2 时间的获取</h4><ul>
<li><p>获取年月日</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前日期年份</span></span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> currentDateTime.getYear();</span><br><span class="line"><span class="comment">//获取当前日期的月份枚举值</span></span><br><span class="line"><span class="type">Month</span> <span class="variable">month</span> <span class="operator">=</span> currentDateTime.getMonth();</span><br><span class="line"><span class="comment">//获取当前日期月份的整数值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">monthValue</span> <span class="operator">=</span> currentDateTime.getMonthValue();</span><br><span class="line"><span class="comment">//获取月份中的第几天(取值范围 1~31)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> currentDateTime.getDayOfMonth();</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取时分秒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取时(小时)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> currentDateTime.getHour();</span><br><span class="line"><span class="comment">//获取分钟</span></span><br><span class="line"><span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> currentDateTime.getMinute();</span><br><span class="line"><span class="comment">//获取秒</span></span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> currentDateTime.getSecond();</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取星期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DayOfWeek</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> localDateTime.getDayOfWeek();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-3-时间的计算"><a href="#2-3-时间的计算" class="headerlink" title="2.3 时间的计算"></a>2.3 时间的计算</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算加一年/减一年或者加几年/减几年</span></span><br><span class="line"><span class="comment"> * 计算加一个月/减一个月或者加几个月/减几个月</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">currentDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTimePlusY1</span> <span class="operator">=</span> currentDateTime.plusYears(<span class="number">10</span>);<span class="comment">//加10年</span></span><br><span class="line">System.out.println(<span class="string">&quot;加10年: &quot;</span>+localDateTimePlusY1);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTimePlusY2</span> <span class="operator">=</span> currentDateTime.minusYears(<span class="number">5</span>);<span class="comment">//减5年</span></span><br><span class="line">System.out.println(<span class="string">&quot;减5年: &quot;</span>+localDateTimePlusY2);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTimePlusM1</span> <span class="operator">=</span> currentDateTime.plusMonths(<span class="number">2</span>);<span class="comment">//加2月</span></span><br><span class="line">System.out.println(<span class="string">&quot;加2月: &quot;</span>+localDateTimePlusM1);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTimePlusM2</span> <span class="operator">=</span> currentDateTime.minusMonths(<span class="number">2</span>);<span class="comment">//减2月</span></span><br><span class="line">System.out.println(<span class="string">&quot;减2月: &quot;</span>+localDateTimePlusM2);</span><br><span class="line"><span class="comment">//...其他请查找API</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-时间的修改"><a href="#2-4-时间的修改" class="headerlink" title="2.4 时间的修改"></a>2.4 时间的修改</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改日期和时间</span></span><br><span class="line"><span class="comment"> * 可以对当前的日期时间进行修改</span></span><br><span class="line"><span class="comment"> * withYear        : 设置年</span></span><br><span class="line"><span class="comment"> * withMonth       : 设置月</span></span><br><span class="line"><span class="comment"> * withDayOfMonth  : 设置日</span></span><br><span class="line"><span class="comment"> * withHour        : 设置小时</span></span><br><span class="line"><span class="comment"> * withMinute      : 设置分钟</span></span><br><span class="line"><span class="comment"> * withSecond      : 设置秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> currentDateTime.withYear(<span class="number">2018</span>).withMonth(<span class="number">12</span>).withDayOfMonth(<span class="number">30</span>).withHour(<span class="number">12</span>).withMinute(<span class="number">10</span>).withSecond(<span class="number">59</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-5-时间的转换"><a href="#2-5-时间的转换" class="headerlink" title="2.5 时间的转换"></a>2.5 时间的转换</h4><h5 id="2-5-1-时间转字符串"><a href="#2-5-1-时间转字符串" class="headerlink" title="2.5.1 时间转字符串"></a>2.5.1 时间转字符串</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">llts</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(LocalDateTime.now());</span><br></pre></td></tr></table></figure>

<h5 id="2-5-2-时间转时间戳"><a href="#2-5-2-时间转时间戳" class="headerlink" title="2.5.2 时间转时间戳"></a>2.5.2 时间转时间戳</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">milli</span> <span class="operator">=</span> LocalDateTime.now().toInstant(ZoneOffset.of(<span class="string">&quot;+8&quot;</span>)).toEpochMilli();</span><br></pre></td></tr></table></figure>

<h2 id="第二章-Lambda表达式-函数式接口"><a href="#第二章-Lambda表达式-函数式接口" class="headerlink" title="第二章 Lambda表达式&#x2F;函数式接口"></a>第二章 Lambda表达式&#x2F;函数式接口</h2><h3 id="第1节-Lambda表达式"><a href="#第1节-Lambda表达式" class="headerlink" title="第1节 Lambda表达式"></a>第1节 Lambda表达式</h3><h4 id="1-1-Lambda表达式介绍"><a href="#1-1-Lambda表达式介绍" class="headerlink" title="1.1 Lambda表达式介绍"></a>1.1 Lambda表达式介绍</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> Lambda 表达式也可称为闭包,它是Java8发布的最重要新特性</span><br><span class="line"><span class="bullet">2.</span> Lambda 允许把函数作为一个方法的参数</span><br><span class="line"><span class="bullet">3.</span> Lambda 表达式可以使代码变的更加简洁紧凑</span><br></pre></td></tr></table></figure>

<h4 id="1-2-Lambda表达式语法"><a href="#1-2-Lambda表达式语法" class="headerlink" title="1.2 Lambda表达式语法"></a>1.2 Lambda表达式语法</h4><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">(parameters)</span> -&gt;</span> expression</span><br><span class="line">或</span><br><span class="line"><span class="function"><span class="params">(parameters)</span> -&gt;</span>&#123; statements; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-Lambda表达式的演进"><a href="#1-3-Lambda表达式的演进" class="headerlink" title="1.3 Lambda表达式的演进"></a>1.3 Lambda表达式的演进</h4><blockquote>
<p>对于Java变量我们可以给其赋值(基本数据类型,引用数据类型)</p>
</blockquote>
<img src="https://note.youdao.com/yws/api/personal/file/WEBfd76fd1faecfdf26bd604a0a4eac9248?method=download&shareKey=dd6af32637f99f8d5f0defaa70bc69ee">

<blockquote>
<p>如果想把”一块代码”赋给一个Java变量,应该怎么做呢？</p>
</blockquote>
<img src="https://note.youdao.com/yws/api/personal/file/WEBea77f7addbe5ba4d5e8f64fe90d9dfca?method=download&shareKey=73e2dbe02eb7cca0615e4b7aed77e344">

<blockquote>
<p>在Java 8之前,这个是做不到的,但是Java8问世之后,利用Lambda特性,就可以做到了</p>
</blockquote>
<img src="https://note.youdao.com/yws/api/personal/file/WEB2db9bf18a1c3f14d2baf9c6e02d88453?method=download&shareKey=6cd6f1e2559c27ee1f2bbaa69cf77b9a">

<blockquote>
<p>上面的写法并不是一个很简洁的写法,为了让这个赋值更加优雅,我们可以移除一些多余的声明</p>
</blockquote>
<img src="https://note.youdao.com/yws/api/personal/file/WEBc76d3456f05cc3b78423cb58fb208e0c?method=download&shareKey=cdc334a630013af3f092552bb779405a">

<blockquote>
<p>这样,我们就成功的非常优雅的把”一块代码”赋给了一个变量,而”这块代码”,或者说”这个被赋给一个变量的函数”,就是一个Lambda表达式;但是这里仍然有一个问题，就是变量aBlockOfCode的类型应该是什么?</p>
</blockquote>
<blockquote>
<p>在Java8里面,所有的Lambda的类型都是一个接口,而Lambda表达式本身,也就是”那段代码”,需要是这个接口的实现.这是我认为理解Lambda的一个关键所在,简而言之就是,Lambda表达式本身就是一个接口的实现.直接这样说可能还是有点让人困扰,我们继续看看例子.我们给上面的aBlockOfCode加上一个类型</p>
</blockquote>
<img src="https://note.youdao.com/yws/api/personal/file/WEB3cdb19fad20ddbafd0a26eed79bc1d61?method=download&shareKey=97bbb3f1bcd3e1c5838ef47ea3d04375">

<blockquote>
<p>这种只有一个接口函数需要被实现的接口类型,我们叫它”函数式接口”.为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现,变成”非函数接口”,我们可以在这个上面加上一个声明@FunctionalInterface,这样别人就无法在里面添加新的接口函数了</p>
</blockquote>
<img src="https://note.youdao.com/yws/api/personal/file/WEB172d250168f0eed2770c42148040559d?method=download&shareKey=e73b4640a1e3b93d1c36f802900006f4">

<blockquote>
<p>这样,我们就得到了一个完整的Lambda表达式声明</p>
</blockquote>
<img src="https://note.youdao.com/yws/api/personal/file/WEB4db164cc41e98e7ef160e23dc1191e82?method=download&shareKey=a4f2e8b07f87e15e99455949d76adfd5">

<h4 id="1-4-Lambda表达式的作用"><a href="#1-4-Lambda表达式的作用" class="headerlink" title="1.4 Lambda表达式的作用"></a>1.4 Lambda表达式的作用</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">最直观的作用就是使得代码变得异常简洁</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对比一下Lambda表达式和传统的Java对同一个接口的实现</p>
</blockquote>
<img src="https://note.youdao.com/yws/api/personal/file/WEBf10cb8d7796f3b0c7b334d7433ab513d?method=download&shareKey=c46aec3289a3429dfd94cdf7dc501686">

<blockquote>
<p>这两种写法本质上是等价的.但是显然,Java8中的写法更加优雅简洁.并且,由于Lambda可以直接赋值给一个变量,我们就可以直接把Lambda作为参数传给函数,而传统的Java必须有明确的接口实现的定义,初始化才行</p>
</blockquote>
<img src="https://note.youdao.com/yws/api/personal/file/WEBdbbfc0490ac5e5bd4fd683b312087571?method=download&shareKey=4f1bfe454ac5c3a5781508e0b9c7e885">

<blockquote>
<p>有些情况下,这个接口实现只需要用到一次.传统的Java7必须要求你定义一个”污染环境”的接口实现MyInterfaceImpl,而相较之下Java8的Lambda,就显得干净很多</p>
</blockquote>
<h4 id="1-5-Lambda表达式的简单使用"><a href="#1-5-Lambda表达式的简单使用" class="headerlink" title="1.5 Lambda表达式的简单使用"></a>1.5 Lambda表达式的简单使用</h4><blockquote>
<p>定义函数式接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@WebSite</span>    : ukoko.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>       : 2020/11/8 12:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自定义函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyLambdaInterface</span> &#123;</span><br><span class="line">    <span class="comment">//测试求a+b和</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">testMethodAdd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数式接口的特点:</span><br><span class="line"><span class="number">1.</span> 要是一个接口</span><br><span class="line"><span class="number">2.</span> 接口内有且只有一个抽象方法</span><br><span class="line"><span class="number">3.</span> 为了防止破坏函数式接口,最好是在接口上面使用<span class="meta">@FunctionalInterface</span>注解修饰</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数式接口的使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@WebSite</span>     : ukoko.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>        : 2020/11/8 12:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> : Lambda表达式简单使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传统方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//匿名内部类(或者是定义一个外部类来实现此接口,然后实例化外部类的方式)</span></span><br><span class="line">        <span class="type">MyLambdaInterface</span> <span class="variable">myLambdaInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLambdaInterface</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">testMethodAdd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a+b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">methodAdd</span> <span class="operator">=</span> myLambdaInterface.testMethodAdd(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">        System.out.println(methodAdd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lambda表达式方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//如果箭头右侧加大括号,不能去掉return关键字</span></span><br><span class="line">        <span class="type">MyLambdaInterface</span> <span class="variable">myLambdaInterface</span> <span class="operator">=</span> (a,b)-&gt;&#123;<span class="keyword">return</span> a+b;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">methodAdd</span> <span class="operator">=</span> myLambdaInterface.testMethodAdd(<span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line">        System.out.println(methodAdd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-Lambda在Java8中的应用"><a href="#1-6-Lambda在Java8中的应用" class="headerlink" title="1.6 Lambda在Java8中的应用"></a>1.6 Lambda在Java8中的应用</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Java8中对很多的API进行了修改,加入了函数式编程的语法</span><br></pre></td></tr></table></figure>

<blockquote>
<p>比如集合框架的修改</p>
<blockquote>
<p>对一个集合中的数据进行排序</p>
</blockquote>
</blockquote>
<ul>
<li>普通实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;lilei&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;hanmeimei&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;jim&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;排序前: &quot;</span>+list);</span><br><span class="line">    <span class="comment">//使用Collections工具类进行排序(JDK7)</span></span><br><span class="line">    Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;排序后: &quot;</span>+list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Lambda实现</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span>()</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.<span class="keyword">add</span>(<span class="string">&quot;lilei&quot;</span>);</span><br><span class="line">    list.<span class="keyword">add</span>(<span class="string">&quot;hanmeimei&quot;</span>);</span><br><span class="line">    list.<span class="keyword">add</span>(<span class="string">&quot;jim&quot;</span>);</span><br><span class="line">    list.<span class="keyword">add</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">&quot;排序前: &quot;</span>+list);</span><br><span class="line">    <span class="comment">//使用Collections工具类进行排序(如果箭头右侧不加大括号,可以去掉return关键字)</span></span><br><span class="line">    Collections.sort(list,(s1,s2)-&gt;s1.compareTo(s2));</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">&quot;排序后: &quot;</span>+list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第2节-函数式接口"><a href="#第2节-函数式接口" class="headerlink" title="第2节 函数式接口"></a>第2节 函数式接口</h3><h4 id="2-1-函数式接口介绍"><a href="#2-1-函数式接口介绍" class="headerlink" title="2.1 函数式接口介绍"></a>2.1 函数式接口介绍</h4><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">函数式接口(Functional <span class="keyword">Interface</span>)就是一个有且仅有一个抽象方法,但是可以有多个非抽象方法的接口</span><br><span class="line"></span><br><span class="line">Java8中新增了很多的函数式接口在java.util.<span class="keyword">function</span>包下,在其他包下也有函数式接口</span><br></pre></td></tr></table></figure>

<h4 id="2-2-常见的函数式接口"><a href="#2-2-常见的函数式接口" class="headerlink" title="2.2 常见的函数式接口"></a>2.2 常见的函数式接口</h4><ul>
<li><p>java.util.function包下函数式接口</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.Runnable</span></span><br><span class="line">java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.Callable</span></span><br><span class="line">java<span class="selector-class">.util</span><span class="selector-class">.Comparator</span></span><br><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.InvocationHandler</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他包常见的函数式接口</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">BiConsumer&lt;T,U&gt;     :代表了一个接受两个输入参数的操作,并且不返回任何结果</span><br><span class="line">BiFunction&lt;T,U,R&gt;   :代表了一个接受两个输入参数的方法，并且返回一个结果</span><br><span class="line">Consumer&lt;T&gt;         :代表了接受一个输入参数并且无返回的操作</span><br><span class="line"><span class="symbol">DoubleBinaryOperator:</span>代表了作用于两个<span class="type">double</span>值操作符的操作，并且返回了一个<span class="type">double</span>值的结果</span><br><span class="line">DoubleConsumer      :代表一个接受<span class="type">double</span>值参数的操作,并且不返回结果</span><br><span class="line">DoubleFunction&lt;R&gt;   :代表接受一个<span class="type">double</span>值参数的方法，并且返回结果</span><br><span class="line"></span><br><span class="line">... 其他请查询API文档</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-3-函数式接口使用-JDK8提供"><a href="#2-3-函数式接口使用-JDK8提供" class="headerlink" title="2.3 函数式接口使用(JDK8提供)"></a>2.3 函数式接口使用(JDK8提供)</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestFunctionInterface &#123;</span><br><span class="line">    @Test</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> test01()&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 接受两个输入参数的操作</span></span><br><span class="line"><span class="comment">         * 没有返回值的函数式接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BiConsumer&lt;<span class="type">Integer</span>,<span class="type">Integer</span>&gt; biConsumer = (a,b)-&gt; <span class="keyword">System</span>.<span class="keyword">out</span>.println(a+b);</span><br><span class="line">        biConsumer.accept(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> test02()&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 接受两个输入参数的操作</span></span><br><span class="line"><span class="comment">         * 并且有返回值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BiFunction&lt;<span class="type">Integer</span>,<span class="type">Integer</span>,<span class="type">Integer</span>&gt; biFunction = (x,y)-&gt; x+y;</span><br><span class="line">        <span class="type">Integer</span> sum = biFunction.apply(<span class="number">10000</span>, <span class="number">20000</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;sum= &quot;+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三章-默认方法-静态方法"><a href="#第三章-默认方法-静态方法" class="headerlink" title="第三章 默认方法&#x2F;静态方法"></a>第三章 默认方法&#x2F;静态方法</h2><h3 id="第1节-默认方法"><a href="#第1节-默认方法" class="headerlink" title="第1节 默认方法"></a>第1节 默认方法</h3><h4 id="1-1-默认方法介绍"><a href="#1-1-默认方法介绍" class="headerlink" title="1.1 默认方法介绍"></a>1.1 默认方法介绍</h4><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">默认方法就是接口可以有实现方法,而且不需要实现类去实现其方法</span><br><span class="line">Java8之前接口里面的方法必须全部都是抽象方法,没有方法体</span><br><span class="line">Java8之后接口中可以定义带有方法体的方法,但是需要在方法前加<span class="keyword">default</span>关键字进行修饰</span><br></pre></td></tr></table></figure>

<h4 id="1-2-默认方法语法"><a href="#1-2-默认方法语法" class="headerlink" title="1.2 默认方法语法"></a>1.2 默认方法语法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyLambdaInterface</span> &#123;</span><br><span class="line">	<span class="comment">//默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">testDefaultMethod</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-默认方法使用"><a href="#1-3-默认方法使用" class="headerlink" title="1.3 默认方法使用"></a>1.3 默认方法使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认方法的调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取实例</span></span><br><span class="line">    <span class="type">MyLambdaInterface</span> <span class="variable">myLambdaInterface</span> <span class="operator">=</span> (a,b)-&gt;a+b;</span><br><span class="line">    <span class="comment">//调用默认方法</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">method1</span> <span class="operator">=</span> myLambdaInterface.testDefaultMethod(<span class="number">100</span>, <span class="number">300</span>);</span><br><span class="line">    System.out.println(method1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 如果多个接口定义相同名称和类型的默认方法,因为接口的多实现特性可能会让子类中出现不知道该怎么调用父类接口中默认方法的问题,解决方案有两种,一种是在子类中创建自己的默认方法,覆盖原有的默认方法,第二种是使用父类名.super.方法名进行调用</p>
</blockquote>
<h3 id="第2节-静态方法"><a href="#第2节-静态方法" class="headerlink" title="第2节 静态方法"></a>第2节 静态方法</h3><h4 id="2-1-静态方法介绍"><a href="#2-1-静态方法介绍" class="headerlink" title="2.1 静态方法介绍"></a>2.1 静态方法介绍</h4><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">静态方法和默认方法差不多,就是将<span class="keyword">default</span>修饰符修改成statis</span><br></pre></td></tr></table></figure>

<h4 id="2-2-静态方法语法"><a href="#2-2-静态方法语法" class="headerlink" title="2.2 静态方法语法"></a>2.2 静态方法语法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyLambdaInterface</span> &#123;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">testStaticMethod</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-静态方法使用"><a href="#2-3-静态方法使用" class="headerlink" title="2.3 静态方法使用"></a>2.3 静态方法使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//调用静态方法(接口名.方法名)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">method</span> <span class="operator">=</span> MyLambdaInterface.testStaticMethod(<span class="number">1000</span>, <span class="number">2000</span>);</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第四章-方法引用"><a href="#第四章-方法引用" class="headerlink" title="第四章 方法引用"></a>第四章 方法引用</h2><h3 id="第1节-方法引用介绍"><a href="#第1节-方法引用介绍" class="headerlink" title="第1节 方法引用介绍"></a>第1节 方法引用介绍</h3><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">我们在说方法引用前,先说一下Lambda表达式的组成</span><br><span class="line">(a,b)-&gt;&#123;<span class="keyword">return</span> a+b;&#125;</span><br><span class="line">或者</span><br><span class="line">(a,b)-&gt; a+b;</span><br><span class="line"></span><br><span class="line">左侧的括号: 函数式接口里面定义的抽象方法的形参列表</span><br><span class="line">箭头: Lambda表达式的操作符,看见这个箭头,就可以认为他是一个Lambda表达式</span><br><span class="line">右侧Lambda体: 函数式接口中,我们实现了函数式接口抽象方法的方法体</span><br><span class="line"></span><br><span class="line">对于右侧的Lambda体,可以是一个自定义的表达式(比如上面的a+b)</span><br><span class="line">或者是仅仅调用一个已经存在的方法,这种情况下,可以使用方法引用的方式调用这个已经存在的方法.方法引用的操作符<span class="comment">(::)</span>两个冒号.</span><br></pre></td></tr></table></figure>

<h3 id="第2节-方法引用的语法分类"><a href="#第2节-方法引用的语法分类" class="headerlink" title="第2节 方法引用的语法分类"></a>第2节 方法引用的语法分类</h3><table>
<thead>
<tr>
<th>类型</th>
<th>语法</th>
<th>对应的Lambda表达式</th>
</tr>
</thead>
<tbody><tr>
<td>类静态方法引用</td>
<td>类名::staticMethod</td>
<td>(args) -&gt; 类名.staticMethod(args)</td>
</tr>
<tr>
<td>实例方法引用</td>
<td>inst::instMethod</td>
<td>(args) -&gt; inst.instMethod(args)</td>
</tr>
<tr>
<td>类普通方法引用</td>
<td>类名::instMethod</td>
<td>(inst,args) -&gt; 类名.instMethod(args)</td>
</tr>
<tr>
<td>构造方法引用</td>
<td>类名::new</td>
<td>(args) -&gt; new 类名(args)</td>
</tr>
</tbody></table>
<h3 id="第3节-引用的使用"><a href="#第3节-引用的使用" class="headerlink" title="第3节 引用的使用"></a>第3节 引用的使用</h3><h4 id="3-1-静态方法引用"><a href="#3-1-静态方法引用" class="headerlink" title="3.1 静态方法引用"></a>3.1 静态方法引用</h4><ul>
<li><p>静态方法介绍</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Lambda表达式中调用某个类的静态方法,且Lambda表达式的参数作为静态方法的入参传入,最后Lambda的方法返回类型要和静态方法的返回类型对上.</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Lambda方式(传统)和Lambda方式(方法引用)方式进行类型转换</span></span><br><span class="line"><span class="comment"> * 静态方法引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//使用Lambda表达式的方式进行String到Integer类型的转换</span></span><br><span class="line">    Function&lt;String,Integer&gt; function=x-&gt;Integer.parseInt(x);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">apply</span> <span class="operator">=</span> function.apply(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">    System.out.println(apply);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用方法引用的方式(Lambda的另一种形式)</span></span><br><span class="line">    Function&lt;String,Integer&gt; fun = Integer::parseInt; <span class="comment">//相当于x-&gt;Integer.parseInt(x)</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">apply1</span> <span class="operator">=</span> fun.apply(<span class="string">&quot;300&quot;</span>);</span><br><span class="line">    System.out.println(apply1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-2-实例方法引用"><a href="#3-2-实例方法引用" class="headerlink" title="3.2 实例方法引用"></a>3.2 实例方法引用</h4><ul>
<li><p>实例方法介绍</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Lambda表达式中调用某个类的对象的实例方法,且Lambda表达式的参数作为方法的入参传入,最后Lambda的方法返回类型要和实例方法的返回类型对上</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();<span class="comment">//实例对象</span></span><br><span class="line">    <span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> (x,y)-&gt;x+y; <span class="comment">//Lambda表达式</span></span><br><span class="line">    System.out.println(b1.count(<span class="number">1</span>,<span class="number">100</span>));</span><br><span class="line">    <span class="type">B</span> <span class="variable">b2</span> <span class="operator">=</span> a::sum; <span class="comment">//实例方法引用(实例名称::方法名),相当于(x,y)-&gt;x+y</span></span><br><span class="line">    System.out.println(b2.count(<span class="number">2</span>,<span class="number">200</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-3-类普通方法引用"><a href="#3-3-类普通方法引用" class="headerlink" title="3.3 类普通方法引用"></a>3.3 类普通方法引用</h4><ul>
<li><p>类普通方法介绍</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Lambda</span>表达式中调用Lambda形参中第一个参数的某个实例方法,并且Lambda形参剩余的n-<span class="number">1</span>个参数作为这个实例方法的实参.Lambda的方法返回类型要和对象的实例方法的返回类型对应.</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//Lambda表达式</span></span><br><span class="line">    Function&lt;String,String&gt; fun1 = (x)-&gt;x.toUpperCase();</span><br><span class="line">    System.out.println(fun1.apply(<span class="string">&quot;abcdefg&quot;</span>));</span><br><span class="line">    <span class="comment">//类普通方法引用(类名::方法名),相当于(x)-&gt;x.toUpperCase()</span></span><br><span class="line">    Function&lt;String,String&gt; fun2 = String::toUpperCase;</span><br><span class="line">    System.out.println(fun2.apply(<span class="string">&quot;hijklmn&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-4-构造方法引用"><a href="#3-4-构造方法引用" class="headerlink" title="3.4 构造方法引用"></a>3.4 构造方法引用</h4><ul>
<li><p>构造方法介绍</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Lambda的形参作为某个类的构造方法/方法的实参</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">createUser</span><span class="params">(Supplier&lt;User&gt; supplier)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//传统Lambda表达式</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> User.createUser(()-&gt;&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();&#125;);</span><br><span class="line">    user1.setUserId(<span class="number">1001</span>);</span><br><span class="line">    user1.setUserName(<span class="string">&quot;李雷&quot;</span>);</span><br><span class="line">    <span class="comment">//构造器方法引用</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> User.createUser(User::<span class="keyword">new</span>);</span><br><span class="line">    user2.setUserId(<span class="number">2001</span>);</span><br><span class="line">    user2.setUserName(<span class="string">&quot;韩梅梅&quot;</span>);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第五章-Stream-API"><a href="#第五章-Stream-API" class="headerlink" title="第五章 Stream API"></a>第五章 Stream API</h2><h3 id="第1节-Stream-API介绍"><a href="#第1节-Stream-API介绍" class="headerlink" title="第1节 Stream API介绍"></a>第1节 Stream API介绍</h3><h4 id="1-1-Stream是什么"><a href="#1-1-Stream是什么" class="headerlink" title="1.1 Stream是什么?"></a>1.1 Stream是什么?</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Stream</span> API是Java8中加入的一套新的API,主要用于处理一组数据的操作</span><br><span class="line">它的处理方式与传统的方式不同,称为<span class="string">&quot;数据流处理&quot;</span></span><br><span class="line">就是将集合/数组/文件/函数等数据转换成流之后再处理(比如对集合数据进行过滤,排序等操作)</span><br><span class="line"><span class="built_in">Stream</span>并不是数据结构所以不能保存数据,主要目的在于计算</span><br></pre></td></tr></table></figure>

<h4 id="1-2-简述Stream优势"><a href="#1-2-简述Stream优势" class="headerlink" title="1.2 简述Stream优势"></a>1.2 简述Stream优势</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="comment">//用户ID</span></span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="comment">//用户名称</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="comment">//用户年龄</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//班级ID</span></span><br><span class="line">    <span class="keyword">private</span> Integer classId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建集合</span></span><br><span class="line">List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 生成数据略</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK7,从集合中过滤出年级小于18的用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">    <span class="keyword">if</span>(user.getAge()&lt;<span class="number">18</span>)&#123;<span class="comment">//小于18的用户</span></span><br><span class="line">        System.out.println(<span class="string">&quot;JDK7 &gt;&gt;&gt;年纪小于18的用户为: &quot;</span>+user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK8流操作</span></span><br><span class="line"><span class="comment"> * 1. 现将集合转换成Stream</span></span><br><span class="line"><span class="comment"> * 2. 使用内部提供的方法操作</span></span><br><span class="line"><span class="comment"> * 3. JDK8的流式操作不仅仅有过滤还有排序,限制个数,去重,以及类似于数据的组函数的操作等.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//转换成Stream</span></span><br><span class="line">Stream&lt;User&gt; userStream = users.stream();</span><br><span class="line"><span class="comment">//过滤和排序转换回集合</span></span><br><span class="line">List&lt;User&gt; userList = userStream.filter(x -&gt; x.getAge() &lt; <span class="number">18</span>).sorted((x,y)-&gt;y.getClassId().compareTo(x.getClassId())).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;JDK8 &gt;&gt;&gt;年纪小于18的用户为: &quot;</span>+userList);</span><br></pre></td></tr></table></figure>

<h3 id="第2节-Stream-API使用"><a href="#第2节-Stream-API使用" class="headerlink" title="第2节 Stream API使用"></a>第2节 Stream API使用</h3><h4 id="2-1-生成Stream的方式"><a href="#2-1-生成Stream的方式" class="headerlink" title="2.1 生成Stream的方式"></a>2.1 生成Stream的方式</h4><ul>
<li><p>通过集合生成Stream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream1 = list.stream();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过数组生成Stream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream2</span> <span class="operator">=</span> Arrays.stream(arr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过值生成Stream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream3 = Stream.of(<span class="number">100</span>, <span class="number">200</span>, <span class="number">150</span>, <span class="number">210</span>, <span class="number">105</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过文件生成Stream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream4=Files.lines(Paths.get(<span class="string">&quot;stream.txt&quot;</span>),Charset.defaultCharset());</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过函数生成Stream</p>
</li>
<li><ul>
<li><p>iterator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过iterator生成5个偶数Stream,iterator生成的流为无限流,所以用limit截断,只生成5个</span></span><br><span class="line">Stream&lt;Integer&gt; stream5 = Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>generator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过generator生成5个随机数,generator生成的流为无限流,所以用limit截断,只生成5个</span></span><br><span class="line">Stream&lt;Double&gt; stream6 = Stream.generate(Math::random).limit(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-2-Stream的使用"><a href="#2-2-Stream的使用" class="headerlink" title="2.2 Stream的使用"></a>2.2 Stream的使用</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">流的操作类型主要分为两种:</span><br><span class="line"><span class="bullet">1.</span> 中间操作</span><br><span class="line"><span class="bullet">2.</span> 终端操作</span><br></pre></td></tr></table></figure>

<h5 id="2-2-1-中间操作"><a href="#2-2-1-中间操作" class="headerlink" title="2.2.1 中间操作"></a>2.2.1 中间操作</h5><blockquote>
<p>一个流可以后面跟随零个或多个中间操作,目的是打开流,做出将要对数据进行某种操作的指示,然后返回一个新流,交给下一个操作使用.这种操作是惰性的,仅仅调用了这个类的方法,并不会进行具体的操作,真正操作需等到终端操作</p>
</blockquote>
<h6 id="2-2-1-1-filter筛选"><a href="#2-2-1-1-filter筛选" class="headerlink" title="2.2.1.1 filter筛选"></a>2.2.1.1 filter筛选</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">65</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = integers.stream();</span><br><span class="line">    <span class="comment">//filter筛选(筛选出大于3的)</span></span><br><span class="line">    List&lt;Integer&gt; collect = stream.filter(x -&gt; x &gt; <span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;原数据:&quot;</span>+integers);</span><br><span class="line">    System.out.println(<span class="string">&quot;筛选之后的数据:&quot;</span>+collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-1-2-distinct去除重复元素"><a href="#2-2-1-2-distinct去除重复元素" class="headerlink" title="2.2.1.2 distinct去除重复元素"></a>2.2.1.2 distinct去除重复元素</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">65</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = integers.stream();</span><br><span class="line">    <span class="comment">//distinct去除重复元素</span></span><br><span class="line">    List&lt;Integer&gt; collect = stream.distinct().collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;原数据:&quot;</span>+integers);</span><br><span class="line">    System.out.println(<span class="string">&quot;去重之后的数据:&quot;</span>+collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-1-3-limit返回指定流个数"><a href="#2-2-1-3-limit返回指定流个数" class="headerlink" title="2.2.1.3 limit返回指定流个数"></a>2.2.1.3 limit返回指定流个数</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">65</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = integers.stream();</span><br><span class="line">    <span class="comment">//limit返回指定流个数</span></span><br><span class="line">    List&lt;Integer&gt; collect = stream.limit(<span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;原数据:&quot;</span>+integers);</span><br><span class="line">    System.out.println(<span class="string">&quot;目标数据:&quot;</span>+collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-1-4-skip跳过流中的元素"><a href="#2-2-1-4-skip跳过流中的元素" class="headerlink" title="2.2.1.4 skip跳过流中的元素"></a>2.2.1.4 skip跳过流中的元素</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">65</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = integers.stream();</span><br><span class="line">    <span class="comment">//skip跳过流中几个元素</span></span><br><span class="line">    List&lt;Integer&gt; collect = stream.skip(<span class="number">10</span>).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;原数据:&quot;</span>+integers);</span><br><span class="line">    System.out.println(<span class="string">&quot;目标数据:&quot;</span>+collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-1-5-map流映射"><a href="#2-2-1-5-map流映射" class="headerlink" title="2.2.1.5 map流映射"></a>2.2.1.5 map流映射</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = integers.stream();</span><br><span class="line">    <span class="comment">//map流映射(将当前的元素映射成另外一个元素)[将int类型映射成String类型]</span></span><br><span class="line">    List&lt;String&gt; collect = stream.map(x -&gt; x.toString()).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;原数据:&quot;</span>+integers);</span><br><span class="line">    System.out.println(<span class="string">&quot;目标数据:&quot;</span>+collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-1-6-flatMap流转换"><a href="#2-2-1-6-flatMap流转换" class="headerlink" title="2.2.1.6 flatMap流转换"></a>2.2.1.6 flatMap流转换</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;H e l l o&quot;</span>, <span class="string">&quot;Java8&quot;</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;String&gt; stream = strings.stream();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * flatMap流转换(将一个流中的每个值都转换为另一个流)</span></span><br><span class="line"><span class="comment">     * 先将集合中的每个字符串都转成转换成数组</span></span><br><span class="line"><span class="comment">     * 在将数组转换成Stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;String&gt; collect = stream.map(x -&gt; x.split(<span class="string">&quot; &quot;</span>)).flatMap(Arrays::stream).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;原数据:&quot;</span>+strings);</span><br><span class="line">    System.out.println(<span class="string">&quot;目标数据:&quot;</span>+collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-1-7-元素匹配"><a href="#2-2-1-7-元素匹配" class="headerlink" title="2.2.1.7 元素匹配"></a>2.2.1.7 元素匹配</h6><blockquote>
<p>提供了三种匹配方式</p>
<blockquote>
<ol>
<li>allMatch匹配所有</li>
<li>anyMatch匹配其中一个</li>
<li>noneMatch全部不匹配</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素匹配</span></span><br><span class="line"><span class="comment">     * 1. allMatch匹配所有</span></span><br><span class="line"><span class="comment">     * 2. anyMatch匹配其中一个</span></span><br><span class="line"><span class="comment">     * 3. noneMatch全部不匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//匹配Stream中的所有元素是否都大于3,如果大于3返回true,否则返回false</span></span><br><span class="line">    <span class="keyword">if</span>(integers.stream().allMatch(x -&gt; x &gt; <span class="number">3</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;全部大于3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//anyMatch匹配其中一个,有一个成立即可</span></span><br><span class="line">    <span class="keyword">if</span>(integers.stream().anyMatch(x -&gt; x &gt; <span class="number">3</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;存在大于3的数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//noneMatch全部不匹配</span></span><br><span class="line">    <span class="keyword">if</span>(integers.stream().noneMatch(x -&gt; x &gt; <span class="number">3</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;全部小于等于3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-终端操作"><a href="#2-2-2-终端操作" class="headerlink" title="2.2.2 终端操作"></a>2.2.2 终端操作</h5><h6 id="2-2-2-1-统计流中元素个数"><a href="#2-2-2-1-统计流中元素个数" class="headerlink" title="2.2.2.1 统计流中元素个数"></a>2.2.2.1 统计流中元素个数</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">65</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = integers.stream();</span><br><span class="line">    <span class="comment">//统计流中元素个数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stream.count();</span><br><span class="line">    System.out.println(<span class="string">&quot;count:&quot;</span>+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-2-2-查找"><a href="#2-2-2-2-查找" class="headerlink" title="2.2.2.2 查找"></a>2.2.2.2 查找</h6><ul>
<li><p>findFirst查找第一个</p>
</li>
<li><p>findAny随机查找一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">100</span>,<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">65</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = integers.stream();</span><br><span class="line">    <span class="comment">//findFirst查找第一个/findAny随机查找一个(如果是串行流,那么和findFirst结果相同,如果是并行流就不一定了)</span></span><br><span class="line">    <span class="comment">//Optional&lt;Integer&gt; first = stream.findFirst();</span></span><br><span class="line">    Optional&lt;Integer&gt; any = stream.findAny();</span><br><span class="line">    <span class="comment">//System.out.println(&quot;first:&quot;+first.get());</span></span><br><span class="line">    System.out.println(<span class="string">&quot;any:&quot;</span>+any.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="2-2-2-3-reduce将流中的元素组合起来"><a href="#2-2-2-3-reduce将流中的元素组合起来" class="headerlink" title="2.2.2.3 reduce将流中的元素组合起来"></a>2.2.2.3 reduce将流中的元素组合起来</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = integers.stream();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将intergers集合中的数据求和(组合起来)</span></span><br><span class="line"><span class="comment">     * reduce方法接受两个入参</span></span><br><span class="line"><span class="comment">     * 1. 代表初始化值</span></span><br><span class="line"><span class="comment">     * 2. BinaryOperator将两个元素组合起来生成一个新元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//Integer reduce = stream.reduce(0, (x, y) -&gt; x + y);</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> stream.reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    System.out.println(reduce);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-2-4-获取流中最小最大值"><a href="#2-2-2-4-获取流中最小最大值" class="headerlink" title="2.2.2.4 获取流中最小最大值"></a>2.2.2.4 获取流中最小最大值</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = integers.stream();</span><br><span class="line">    <span class="comment">//最大值/最小值</span></span><br><span class="line">    <span class="comment">//Optional&lt;Integer&gt; min = stream.min((x, y) -&gt; x.compareTo(y));</span></span><br><span class="line">    <span class="comment">//Optional&lt;Integer&gt; max = stream.max((x, y) -&gt; x.compareTo(y));</span></span><br><span class="line">    Optional&lt;Integer&gt; max = stream.max(Integer::compareTo);</span><br><span class="line">    <span class="comment">//System.out.println(min.get());</span></span><br><span class="line">    System.out.println(max.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-2-4-求和"><a href="#2-2-2-4-求和" class="headerlink" title="2.2.2.4 求和"></a>2.2.2.4 求和</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = integers.stream();</span><br><span class="line">    <span class="comment">//求和(使用sum方法,如果使用sum方法需要mapToInt转换)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> stream.mapToInt(x -&gt; x).sum();</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-2-5-通过averagingInt求平均值"><a href="#2-2-2-5-通过averagingInt求平均值" class="headerlink" title="2.2.2.5 通过averagingInt求平均值"></a>2.2.2.5 通过averagingInt求平均值</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = integers.stream();</span><br><span class="line">    <span class="comment">//求平均值averagingInt,如果流式Double或者Long那么使用AveragingDouble,AveragingLong</span></span><br><span class="line">    <span class="type">Double</span> <span class="variable">collect</span> <span class="operator">=</span> stream.collect(Collectors.averagingInt(Integer::intValue));</span><br><span class="line">    System.out.println(collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-2-6-通过summarizingInt同时求总和、平均值、最大值、最小值"><a href="#2-2-2-6-通过summarizingInt同时求总和、平均值、最大值、最小值" class="headerlink" title="2.2.2.6 通过summarizingInt同时求总和、平均值、最大值、最小值"></a>2.2.2.6 通过summarizingInt同时求总和、平均值、最大值、最小值</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = integers.stream();</span><br><span class="line">    <span class="type">IntSummaryStatistics</span> <span class="variable">collect</span> <span class="operator">=</span> stream.collect(Collectors.summarizingInt(Integer::intValue));</span><br><span class="line">    <span class="comment">//获取平均值</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> collect.getAverage();</span><br><span class="line">    <span class="comment">//获取最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> collect.getMin();</span><br><span class="line">    <span class="comment">//获取最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> collect.getMax();</span><br><span class="line">    System.out.println(average);</span><br><span class="line">    System.out.println(min);</span><br><span class="line">    System.out.println(max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-2-7-通过foreach进行元素遍历"><a href="#2-2-2-7-通过foreach进行元素遍历" class="headerlink" title="2.2.2.7 通过foreach进行元素遍历"></a>2.2.2.7 通过foreach进行元素遍历</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = integers.stream();</span><br><span class="line">    <span class="comment">//stream.forEach(x-&gt; System.out.println(x));</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-2-8-返回集合"><a href="#2-2-2-8-返回集合" class="headerlink" title="2.2.2.8 返回集合"></a>2.2.2.8 返回集合</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = integers.stream();</span><br><span class="line">    List&lt;Integer&gt; collect = stream.collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//Set&lt;Integer&gt; collect1 = stream.collect(Collectors.toSet());</span></span><br><span class="line">    System.out.println(collect);</span><br><span class="line">    <span class="comment">//System.out.println(collect1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-2-9-通过joining拼接流中的元素"><a href="#2-2-2-9-通过joining拼接流中的元素" class="headerlink" title="2.2.2.9 通过joining拼接流中的元素"></a>2.2.2.9 通过joining拼接流中的元素</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;Java8&quot;</span>);</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;String&gt; stream = strings.stream();</span><br><span class="line">    <span class="type">String</span> <span class="variable">collect</span> <span class="operator">=</span> stream.map(s -&gt; s.toString()).collect(Collectors.joining(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">    System.out.println(collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-2-10-通过groupingBy进行分组"><a href="#2-2-2-10-通过groupingBy进行分组" class="headerlink" title="2.2.2.10 通过groupingBy进行分组"></a>2.2.2.10 通过groupingBy进行分组</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;User&gt; users = Arrays.asList(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1001</span>, <span class="string">&quot;李雷&quot;</span>, <span class="number">18</span>), <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1002</span>, <span class="string">&quot;李雷2&quot;</span>, <span class="number">18</span>), <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1003</span>, <span class="string">&quot;李雷3&quot;</span>, <span class="number">19</span>), <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1004</span>, <span class="string">&quot;李雷4&quot;</span>, <span class="number">19</span>));</span><br><span class="line">    <span class="comment">//转换成Stream</span></span><br><span class="line">    Stream&lt;User&gt; stream = users.stream();</span><br><span class="line">    <span class="comment">//根据年龄分组</span></span><br><span class="line">    Map&lt;Integer, List&lt;User&gt;&gt; collect = stream.collect(Collectors.groupingBy(User::getAge));</span><br><span class="line">    System.out.println(collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javase</category>
      </categories>
      <tags>
        <tag>jdk8</tag>
      </tags>
  </entry>
</search>
